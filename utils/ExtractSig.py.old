import sys
sys.path.append("..")
import multiprocessing
from utils.LogExceptions import LogExceptions
import pysam
import os
current_path = os.path.abspath(os.path.dirname(__file__))
current_path = current_path.replace("utils", "")
print("当前路径为：%s ExtractSignal" % current_path)
from loguru import logger
import ctypes
import json
import time
import subprocess
import re

class ExtractSig:
    def __init__(self, samples, bamFiles, mutProces, outPath, chromLengths, minSignal, bam_cram, winSize=10000000):
        self.sampleToBams = dict(zip(samples, bamFiles))
        self.mutProces = mutProces
        self.minSignal = minSignal
        self.min_map_quality = 20
        self.winSize = winSize
        self.outPath = outPath
        self.bam_cram = bam_cram
        self.chromLengthGroups = self.splitChrom(chromLengths)

    def splitChrom(self, chromLengths):
        chromLengthGroups = {}
        for chrom, length in chromLengths.items():
            length = int(length)
            chromLengthGroups[chrom] = []
            if length < self.winSize:
                chromLengthGroups[chrom].append([1, length])
            else:
                multipleTimes = length // self.winSize
                for i in range(multipleTimes):
                    chromLengthGroups[chrom].append([i * self.winSize + 1, (i + 1) * self.winSize])
                if length % self.winSize > 0:
                    chromLengthGroups[chrom].append([multipleTimes * self.winSize + 1, length])
        return chromLengthGroups

    def mergeSignals(self, allFiles):
        task_pool = {}
        for sample, chrData in allFiles.items():
            bedName = os.path.join(self.outPath, sample + '.bed')
            out = open(bedName, 'w')
            # out =  open(bedName, 'wt', compresslevel=9)
            bedLines = []
            for chrom, tmpBeds in chrData.items():
                chromList = []  # sorted_data = sorted(data_list, key=lambda x: (x[0], x[1]))
                for tmpBed in tmpBeds:
                    if os.path.exists(tmpBed):
                        # with gzip.open(tmpBed, 'rt') as inputs:
                        with open(tmpBed, 'rt') as inputs:
                            for lx in inputs:
                                chromList.append(chrom + '\t' + lx)
                                # chromList.append([int(lx.split("\t")[0]), chrom+'\t'+lx])
                        os.remove(tmpBed)
                bedLines.append(''.join(list(set(chromList))))
            out.write(''.join(bedLines))
            out.close()
            task = "LC_ALL=C sort -S 5%% -k1V -k2n -k3n %s |bgzip >%s.gz" % (bedName, bedName)
            #task = "LC_ALL=C sort -S 2G -k1V -k2n -k3n --parallel = 20 --compress-program=gzip %s |bgzip >%s.gz" % (bedName, bedName)
            p = subprocess.Popen(task, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE,
                                 stderr=subprocess.PIPE)
            task_pool[bedName] = p

        bedNames = list(task_pool.keys())
        while len(task_pool) != 0:
            for bedName in bedNames:
                try:
                    intask_Popen = task_pool[bedName]
                except KeyError:
                    continue
                if intask_Popen.poll() != None:
                    # print(time.strftime("[%Y-%m-%d %H:%M:%S]", time.localtime()) + ' '+str(intask_Popen.pid)+': '+' finish...')
                    logger.info(time.strftime("[%Y-%m-%d %H:%M:%S]", time.localtime()) + ' '+str(intask_Popen.pid)+': '+' finish...')
                    pysam.tabix_index(bedName + ".gz", force=True, seq_col=0, start_col=1, end_col=2, preset="bed")
                    del task_pool[bedName]
                    os.remove(bedName)

    def run(self):
        t1 = time.time()
        func = Func()
        multiprocessing.log_to_stderr()
        process_pool = multiprocessing.Pool(self.mutProces)
        allFiles = {}
        for sample, bamfile in self.sampleToBams.items():
            for chrom, lengths in self.chromLengthGroups.items():
                for length in lengths:
                    start, stop = length[0], length[1]
                    tmpBed = str(
                        os.path.join(self.outPath, '_'.join(map(str, [sample, chrom, start, stop])) + ".bed"))
                    if sample in allFiles:
                        if chrom in allFiles[sample]:
                            allFiles[sample][chrom].append(tmpBed)
                        else:
                            allFiles[sample][chrom] = [tmpBed]
                    else:
                        allFiles[sample] = {chrom: [tmpBed]}
                    #self.extractSignals(sample, bamfile, chrom, length[0], length[1], tmpBed)
                    process_pool.apply_async(func=LogExceptions(self.extractSignals),
                                             args=(sample, bamfile, chrom, length[0], length[1], tmpBed, ),
                                             callback=func.call_back, error_callback=func.err_call_back)
        process_pool.close()
        process_pool.join()
        t2 = time.time()
        print(t2 - t1)
        self.mergeSignals(allFiles)
        print(time.time() - t2)

    def cutRead(self, query_start, query_seq, length, query_length):
        tmp_s = query_start
        tmp_e = query_start + length
        if tmp_s < 0:
            tmp_s = 0

        if tmp_e > query_length:
            return query_seq[tmp_s:query_length]
        else:
            return query_seq[tmp_s:tmp_e]

    def cutRead(self, query_start, query_seq, length, query_length):
        tmp_s = max(0, query_start)
        tmp_e = min(query_start + length, query_length)
        return query_seq[tmp_s:tmp_e]

    def dealCigar(self, start, cigar, query_seq, query_length, minSignal):
        refs_start = start
        query_start = 0
        signals = ''
        numbers = ''
        letters = ''
        current_number = ''
        for char in cigar:
            if char.isdigit():
                current_number += char
            else:
                if current_number:
                    numbers = int(current_number)
                    current_number = ''
                letters = char

                if letters != '':
                    if letters == "M":
                        query_start = query_start + numbers
                        refs_start = refs_start + numbers
                    elif letters == "D":
                        refs_stop = refs_start + numbers
                        if numbers >= minSignal:
                            newarray =[refs_start, refs_stop, 2]
                            signals = signals+'\t'+','.join(map(str, newarray))
                        refs_start = refs_stop
                    elif letters == "I":
                        reads_stop = refs_start + numbers
                        if numbers >= minSignal:
                            seq_i = self.cutRead(query_start, query_seq, numbers, query_length)
                            newarray = [refs_start, reads_stop, 3, seq_i]
                            signals = signals+'\t'+','.join(map(str, newarray))
                        query_start = query_start + numbers
                    elif letters == "S":
                        if query_start == 0:
                            query_start = query_start + numbers
                            tmp_start = query_start - numbers
                            if tmp_start >= 0:
                                newarray = [tmp_start, refs_start, 1, query_start]
                                signals = signals+'\t'+','.join(map(str, newarray))
                        else:
                            newarray = [refs_start, refs_start + numbers, 4, query_start]
                            signals = signals+'\t'+','.join(map(str, newarray))

                    numbers = ''
                    letters = ''
        return signals

    def extractSignals(self, sample, bamfile, chrom, start, stop, tmpBed):

        if self.bam_cram:
            samfile = pysam.AlignmentFile(bamfile, "rb")
        else:
            samfile = pysam.AlignmentFile(bamfile, "rc")

        allreads = samfile.fetch(contig=chrom, start=start, stop=stop)
        pattern = r'\d+\.*\d*(?=[SID])'
        with open(tmpBed, 'w') as OutHandle:
            for read in allreads:
                start_time = time.time()
                #if read.flag > 2000:
                #    continue
                if read.mapping_quality < self.min_map_quality:
                    continue
                query_name = read.query_name.split('|')[0]
                ref_start = read.reference_start
                ref_end = read.reference_end
                query_alignment_start = read.query_alignment_start
                query_alignment_end = read.query_alignment_end
                query_length = read.query_length
                is_reverse = '1' if read.is_reverse else '0'
                is_secondart = '1' if read.is_secondary else '0'
                matches = [i for i in map(int, re.findall(pattern, read.cigarstring)) if i > 25]
                exists_greater_than_25 = len(matches) > 0
                if exists_greater_than_25:
                    print("存在大于25的数字")
                else:
                    print("不存在大于25的数字")
                #signals = self.dealCigar(ref_start, read.cigarstring, read.query_sequence, query_length, self.minSignal)
                #OutHandle.write('\t'.join(map(str, [chrom, ref_start, ref_end, query_alignment_start, query_alignment_end, query_length, read.mapping_quality, is_reverse, is_secondart, query_name, signals]))+"\n")
                print("time_deal:", time.time()-start_time)




class Func(object):
    def __init__(self):
        # 利用匿名函数模拟一个不可序列化象
        # 更常见的错误写法是，在这里初始化一个数据库的长链接
        self.num = lambda: None

    def work(self, num=None):
        self.num = num
        return self.num

    @staticmethod
    def call_back(res):
        #print(f'Hello,World! {res}')
        pass

    @staticmethod
    def err_call_back(err):
        print(f'出错啦~ error：{str(err)}')

'''
if __name__ == "__main__":
    sampleToBams = {
        "Father": "/home/lz/work_space/Database/VISOR_test/Chr1_two_new/T2/FY0/VISOR_LASeR_Father_DEL.DUP.INS.INV/sim.srt.bam",
        "Mother": "/home/lz/work_space/Database/VISOR_test/Chr1_two_new/T2/FY0/VISOR_LASeR_Mother_DEL.DUP.INS.INV/sim.srt.bam",
        "Son": "/home/lz/work_space/Database/VISOR_test/Chr1_two_new/T2/FY0/VISOR_LASeR_Son_DEL.DUP.INS.INV/sim.srt.bam"}
    samples = ["Father", "Mother", "Son"]
    bamFiles = ["/home/lz/work_space/Database/VISOR_test/Chr1_two_new/T2/FY0/VISOR_LASeR_Father_DEL.DUP.INS.INV/sim.srt.bam",
                "/home/lz/work_space/Database/VISOR_test/Chr1_two_new/T2/FY0/VISOR_LASeR_Mother_DEL.DUP.INS.INV/sim.srt.bam",
                "/home/lz/work_space/Database/VISOR_test/Chr1_two_new/T2/FY0/VISOR_LASeR_Son_DEL.DUP.INS.INV/sim.srt.bam"]
    genome = "/home/lz/work_space/Database/VISOR_test/Genome_old/Genome.fa"
    chromLengths = dict([i.strip().split('\t')[:2] for i in open(genome + ".fai").read().strip().split('\n')])
    mutProces = 90
    minSignal = 30
    winSize = 10000000
    outPath = "./tmp"
    #samples, bamFiles, mutProces, outPath, chromLengths, minSignal, winSize=10000000
    ext = ExtractSignals(samples, bamFiles, mutProces, outPath, chromLengths,  minSignal, winSize)
    ext.run()
'''
